<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eric's Blog - DevOps</title><link href="https://ericdaat.github.io/" rel="alternate"></link><link href="https://ericdaat.github.io/feeds/devops.atom.xml" rel="self"></link><id>https://ericdaat.github.io/</id><updated>2019-04-12T10:20:00+02:00</updated><subtitle>Data Scientist, Full Stack Developer</subtitle><entry><title>Auto deploy a static website on AWS S3 using CircleCI</title><link href="https://ericdaat.github.io/circleci-s3-static-website.html" rel="alternate"></link><published>2019-04-12T10:20:00+02:00</published><updated>2019-04-12T10:20:00+02:00</updated><author><name>Eric Daoud</name></author><id>tag:ericdaat.github.io,2019-04-12:/circleci-s3-static-website.html</id><summary type="html">&lt;p&gt;In this post we are going to look at how to use CircleCI to automatically deploy a static website hosted on AWS S3. AWS S3 is an easy and cheap way to host a static website, and combined with Cloudfront and Route 53 we can have a highly reliable and secure website. CircleCI is a continuous integration tool, which we will use with Github to push the code to AWS S3 at every commit.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post we are going to look at how to use CircleCI to automatically deploy a static website hosted on AWS S3. AWS S3 is an easy and cheap way to host a static website, and combined with Cloudfront and Route 53 we can have a highly reliable and secure website. CircleCI is a continuous integration tool, which we will use with Github to push the code to AWS S3 at every commit.&lt;/p&gt;
&lt;p&gt;Before getting started, I encourage you to get familiar (if you're not already) with the different tools we are going to use, namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/"&gt;Amazon Web Services&lt;/a&gt; (AWS): A major Cloud Computing vendor&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/s3/"&gt;AWS S3&lt;/a&gt;: Object storage service from AWS. It can be configured to host static websites.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/cloudfront"&gt;AWS Cloudfront&lt;/a&gt;: AWS Content Delivery Network (CDN). We will use this to add SSL to our website. &lt;/li&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/certificate-manager/"&gt;AWS Certificate Manager&lt;/a&gt;: AWS service for getting SSL certificates.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://aws.amazon.com/route53"&gt;AWS Route 53&lt;/a&gt;: Domain Name System (DNS) web service. It is not mandatory to use this, but it makes things easier.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gitub.com"&gt;Github&lt;/a&gt;: The most popular hosting service for version control using Git.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://circleci.com/"&gt;CircleCI&lt;/a&gt;: Continuous Integration (CI) and delivery platform.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Hosting the website on S3&lt;/h2&gt;
&lt;p&gt;Note: There are many great tutorials on how to host a static website on AWS S3, so I won't enter into too much details as the main goal of this post is to show how to use CircleCI to synchronize Github and S3.&lt;/p&gt;
&lt;p&gt;We assume you already have a static website ready. If not, it can be as simple as &lt;code&gt;echo "&amp;lt;p&amp;gt;Hello World&amp;lt;/p&amp;gt;" &amp;gt; index.html&lt;/code&gt;. You will also need to host your code in Github.&lt;/p&gt;
&lt;p&gt;To learn how to host a static website on S3, please follow Step 2 from this page: &lt;a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/website-hosting-custom-domain-walkthrough.html"&gt;Setting up a Static Website Using a Custom Domain&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Create a Cloudfront distribution&lt;/h2&gt;
&lt;p&gt;Once your bucket is ready and has your website in it, you should use a Cloudfront distribution and a SSL certificate to enable HTTPS. You can discover how to do so here: &lt;a href="https://aws.amazon.com/premiumsupport/knowledge-center/cloudfront-serve-static-website/"&gt;How do I use CloudFront to serve a static website hosted on Amazon S3?&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Using a custom domain name&lt;/h2&gt;
&lt;p&gt;This step assumes you have bought a domain name (not necessarily from AWS, I bought mine from &lt;a href="https://www.namecheap.com/"&gt;Namecheap&lt;/a&gt;). &lt;/p&gt;
&lt;p&gt;I prefer using AWS Route 53 for DNS management as it makes things simpler. If you bought your domain name on AWS you don't need any additional configuration. Otherwise, you will need to tell your domain name provider to use AWS name servers.&lt;/p&gt;
&lt;p&gt;Let's say you bought &lt;code&gt;example.com&lt;/code&gt; on Namcheap. You will first need to create a hosted zone on AWS Route 53 named &lt;code&gt;example.com&lt;/code&gt;. After that, you'll see &lt;code&gt;NS&lt;/code&gt; records corresponding to the AWS Name Servers, they might look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ns-995.awsdns-60.net.
ns-1903.awsdns-45.co.uk.
ns-155.awsdns-19.com.
ns-1306.awsdns-35.org.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You'll want to add these to Namecheap, as explained here: &lt;a href="https://www.namecheap.com/support/knowledgebase/article.aspx/767/10/how-to-change-dns-for-a-domain"&gt;How to Change DNS For a Domain&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now Namecheap will redirect to Route53, but you'll need to tell Route53 what to redirect the trafic to. Create record sets like &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;example.com&lt;/code&gt; and make them point to your Cloudfront distribution. &lt;/p&gt;
&lt;p&gt;We are done for the first part, your website hosted in S3 should show at &lt;code&gt;example.com&lt;/code&gt;. Again, we skipped some details for this part as it is not the main goal of this post. Some tutorials explain this part much better than I did. I recommend these ones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.freecodecamp.org/how-to-host-a-website-on-s3-without-getting-lost-in-the-sea-e2b82aa6cd38"&gt;How to Host a Website on S3 Without Getting Lost in the Sea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/devopslinks/how-to-host-your-static-website-with-s3-cloudfront-and-set-up-an-ssl-certificate-9ee48cd701f9"&gt;How to host your static website with S3 &amp;amp; CloudFront and set-up an SSL certificate?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Setting up CircleCI and Github&lt;/h2&gt;
&lt;p&gt;Here's the exciting part: whenever you push changes to Github, CircleCI will sync the code files with the AWS S3 bucket you created.&lt;/p&gt;
&lt;p&gt;We assume you alrady have your static website hosted on Github. If you haven't already, sign up to CircleCI (it's free), and add your Github repo to a CircleCI project. &lt;/p&gt;
&lt;p&gt;CircleCI uses &lt;code&gt;awscli&lt;/code&gt; to sync files with S3, so it requires credentials to login to your AWS account. Go to AWS IAM, and &lt;a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html#id_users_create_cliwpsapi"&gt;create a &lt;code&gt;circleci&lt;/code&gt; user&lt;/a&gt;, with restricted permissions on your S3 bucket.&lt;/p&gt;
&lt;p&gt;When you finish creating the user, you will be given credentials (an ID key and a secret key) that you should store somewhere safe. You will also need to store these as environment variables in CircleCI. Go to your project settings, and under environment variables, add these variables, corresponding to the ones you just downloaded:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS_ACCESS_KEY&lt;/li&gt;
&lt;li&gt;AWS_SECRET_ACCESS_KEY&lt;/li&gt;
&lt;li&gt;AWS_REGION&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now CircleCI will login to you AWS account with the user you created, and it will have the right permissions to push files to your S3 bucket.&lt;/p&gt;
&lt;p&gt;Finally, you'll need to add this configuration file to your Github repository, under &lt;code&gt;.circleci/config.yml&lt;/code&gt;:&lt;/p&gt;
&lt;script src="https://gist.github.com/ericdaat/2a91569f770a479ee1f02596ef94be56.js"&gt;&lt;/script&gt;

&lt;p&gt;Adapt this configuration file to your needs, by changing the S3 bucket url, and modify the files to exclude by the sync command.&lt;/p&gt;
&lt;p&gt;When that's done, push to Github, and see that the pipeline runs correctly on CircleCI. When it succeeds, you should see your files updated on AWS S3.&lt;/p&gt;
&lt;p&gt;Have a look at my &lt;a href="https://github.com/ericdaat/edaoud.com"&gt;personnal website repository&lt;/a&gt; for more details. &lt;/p&gt;
&lt;p&gt;I hope this post was helpful, let me know if you need any help, or if something does not seem right.&lt;/p&gt;</content><category term="S3"></category><category term="aws"></category><category term="code"></category><category term="devops"></category><category term="circleci"></category></entry><entry><title>An introduction to Docker</title><link href="https://ericdaat.github.io/docker-introduction.html" rel="alternate"></link><published>2017-10-25T10:20:00+02:00</published><updated>2017-10-25T10:20:00+02:00</updated><author><name>Eric Daoud</name></author><id>tag:ericdaat.github.io,2017-10-25:/docker-introduction.html</id><summary type="html">&lt;p&gt;A tutorial on how to get started with Docker.&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is a short tutorial to Docker. We will first talk about what Docker is and how it differs from virtual machines. Then, we will learn how to get started and run your first container.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;h2&gt;What is Docker ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;“Docker containers wrap a piece of software in a complete filesystem that
contains everything needed to run: code, runtime, system tools, system libraries
– anything that can be installed on a server. This guarantees that the software
will always run the same, regardless of its environment.”
&lt;em&gt;Source: &lt;a href="https://www.docker.com/what-docker"&gt;Docker Website&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Advantages&lt;/h2&gt;
&lt;p&gt;Docker has some of the following advantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lightweight&lt;ul&gt;
&lt;li&gt;Containers share the same kernel (unlike Virtual Machines)&lt;/li&gt;
&lt;li&gt;Use less RAM&lt;/li&gt;
&lt;li&gt;Share common files (No need to duplicate files on each container)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Open&lt;ul&gt;
&lt;li&gt;Run all major Linux distributions … as well as Windows, on top of any
infrastructure&lt;/li&gt;
&lt;li&gt;Can pull images from official sources (OS like Ubuntu, Debian … or even
pre-configured applications like Redis, Nginx, …)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Secure&lt;ul&gt;
&lt;li&gt;Containers isolate applications from one another&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Virtual Machines vs. Containers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Virtual Machines include the application, necessary binaries and libraries and
entire guest OS&lt;/li&gt;
&lt;li&gt;Containers include application and all of its dependencies, but share the kernel!
 They can run on any computer/infrastructure/cloud&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="vms-vs-containers" src="https://www.docker.com/sites/default/files/containers-vms-together%402x.png"&gt;&lt;/p&gt;
&lt;h1&gt;Installation&lt;/h1&gt;
&lt;p&gt;You will need to do 3 things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/installation/"&gt;Install Docker Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/engine/installation/"&gt;Post steps installation if you use Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.docker.com/compose/install/"&gt;Install Docker Compose&lt;/a&gt; (&lt;em&gt;optional&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below are the commands you will need to install Docker Community Edition (Docker
CE) on Ubuntu/Debian.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get update

sudo apt-get install &lt;span class="se"&gt;\&lt;/span&gt;
    apt-transport-https &lt;span class="se"&gt;\&lt;/span&gt;
    ca-certificates &lt;span class="se"&gt;\&lt;/span&gt;
    curl &lt;span class="se"&gt;\&lt;/span&gt;
    software-properties-common

curl -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class="p"&gt;|&lt;/span&gt; sudo apt-key add -

sudo add-apt-repository &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \&lt;/span&gt;
&lt;span class="s2"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;lsb_release -cs&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt; \&lt;/span&gt;
&lt;span class="s2"&gt;    stable&amp;quot;&lt;/span&gt;

sudo apt-get update

sudo apt-get install docker-ce

sudo docker run hello-world
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;From now on the Docker Engine is installed, but you will only be able to run it
with &lt;em&gt;sudo&lt;/em&gt;, which is not ideal. To fix this, Docker provides some post
installation steps, that correspond to the following commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo groupadd docker
sudo usermod -aG docker &lt;span class="nv"&gt;$USER&lt;/span&gt;
docker run hello-world &lt;span class="c1"&gt;# works without sudo!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I like to use Docker Compose to deploy my containers. You can specify your
containers and their configuration in a &lt;em&gt;yaml&lt;/em&gt; file, and then run them all at
once. To install Docker Compose, run the following commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-&lt;span class="sb"&gt;`&lt;/span&gt;uname -s&lt;span class="sb"&gt;`&lt;/span&gt;-&lt;span class="sb"&gt;`&lt;/span&gt;uname -m&lt;span class="sb"&gt;`&lt;/span&gt; -o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose

docker-compose --version
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;First steps&lt;/h1&gt;
&lt;p&gt;Let's get started and run our first container. A container runs from an image, just like an object is instanciated from an image in Object Oriented Programming. This means that before running a container, we must build or download an existing image.&lt;/p&gt;
&lt;p&gt;Just like OOP, you don't have to start from scratch and you can use prebuilt images to get started. For instance, if you want to run a website in an apache webserver, you can use apache's docker image, and customize it to your needs. You could also start from a lower level, and use a Debian image on which you'd install apache webserver.&lt;/p&gt;
&lt;p&gt;We said earlier that images could be built or downloaded. To build an image, you can use a Dockerfile which is a text file in which you specify the commands to build your docker image. The Dockerfile reference can be found on Docker's website following &lt;a href="https://docs.docker.com/engine/reference/builder/"&gt;this link&lt;/a&gt;. Note that this file must be named "Dockerfile" (keep the capital D).&lt;/p&gt;
&lt;p&gt;A very simple Dockerfile may look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FROM ubuntu
CMD echo &amp;quot;This is a test.&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will pull the ubuntu Docker image, run it and display "This is a test.". After this commands succeeds, the container will stop. This is very important, a container lives as long as the command assigned to it runs. This also means that you must not run more than one application per container.&lt;/p&gt;
&lt;p&gt;In the previous example, we used ubuntu image by pulling it to our own image. A lot of pre-existing images are stored and usable by everybody. They are all available on &lt;a href="https://hub.docker.com/explore/"&gt;Docker Hub&lt;/a&gt;. You can find official images like Debian, Ubuntu, Nginx... But also images than other people built.&lt;/p&gt;
&lt;p&gt;Here are some basic commands to get you started with Docker:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker build . &lt;span class="c1"&gt;# builds a container from a Dockerfile (using the Dockerfile is in the active directory)&lt;/span&gt;
docker pull debian:latest &lt;span class="c1"&gt;# pulls the latest version of the debian image&lt;/span&gt;
docker run &amp;lt;image-name&amp;gt; &lt;span class="c1"&gt;# runs a container from an imqge&lt;/span&gt;
docker ps &lt;span class="c1"&gt;# lists the running containers&lt;/span&gt;
docker ps -a &lt;span class="c1"&gt;# lists all the containers&lt;/span&gt;
docker images &lt;span class="c1"&gt;# lists the built images&lt;/span&gt;
docker rm &amp;lt;container-id&amp;gt; &lt;span class="c1"&gt;# removes a stopped container&lt;/span&gt;
docker rm -f &amp;lt;container-id&amp;gt; &lt;span class="c1"&gt;# force remove a container&lt;/span&gt;
docker rmi &amp;lt;image-id&amp;gt; &lt;span class="c1"&gt;# removes a built image&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Running your first container&lt;/h1&gt;
&lt;p&gt;Let's run an apache webserver, using the &lt;a href="https://hub.docker.com/r/_/httpd/"&gt;Apache HTTP&lt;/a&gt; image.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker pull httpd:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now you should see the httpd image when running &lt;code&gt;docker images&lt;/code&gt; command.&lt;/p&gt;
&lt;p&gt;When you run a container, you can give it several options. Let's have a look at this command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -d -p &lt;span class="m"&gt;80&lt;/span&gt;:80 my_image
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here, we asked docker to run an image called &lt;em&gt;my_image&lt;/em&gt; with the following options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d: The container runs in &lt;em&gt;detached&lt;/em&gt; mode (in background)&lt;/li&gt;
&lt;li&gt;-p: We are mapping the container's port 80 to our localhost:80. This means that we can access the container's application on our host. Without this option, the container would still run, but we woudldn't be able to access its application.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With such a configuration, you can open a web browser and visit &lt;em&gt;localhost&lt;/em&gt;. This will display the container's apache web server content.&lt;/p&gt;
&lt;h2&gt;Attaching volumes&lt;/h2&gt;
&lt;p&gt;Let's say we created a very cool static website in HTML/CSS, and we stored it in our &lt;em&gt;./mywebsite&lt;/em&gt; local directory. So far our apache container only displays the defaut &lt;em&gt;index.html&lt;/em&gt; file. How can we pass the container the awesome website we built ? There are several options, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Copy the content from the host to the container when building the image. This means that the data will be stored within the image. If you save the image and pull it somewhere, you will have a copy of the data with it. If you delete the container, you delete the data. If you want to launch the same container several times, they will all have a distinct copy of the data.&lt;/li&gt;
&lt;li&gt;Link the data between the host and the container. This is often a preferred option. By doing this, you don't store the data within the container, you simply create a link from a folder on your host, to the container. This is called volume mapping. Doing so is much more lightweight, but requires to have the data locally. Another advantage is that if you want to run multiple containers from the same image, they can use the same data. If you change the data locally, the containers will render the newer data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To copy data from the host to the container image, add a &lt;em&gt;COPY&lt;/em&gt; command to your Dockerfile, like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FROM httpd
COPY ./mywebsite/:/usr/local/apache2/htdocs/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To link a volume, add the &lt;em&gt;-v&lt;/em&gt; option to the &lt;em&gt;run&lt;/em&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -d -p &lt;span class="m"&gt;80&lt;/span&gt;:80 -v ./mywebsite/:/usr/local/apache2/htdocs/ httpd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Voila! Your container should now be running an apache web server in detached mode. And since we mapped the volume containing our awesome website, what you see on &lt;em&gt;localhost&lt;/em&gt; is exactly what we have under the local &lt;em&gt;./mywebsite&lt;/em&gt; directory.&lt;/p&gt;
&lt;h2&gt;Docker Compose&lt;/h2&gt;
&lt;p&gt;Often, you will need to build and run many different containers, and using the previously seen commands for each container can become very dull. In this section we will introduce Docker Compose, which is a very handy tool for defining and running multiple containers from a YAML configuration file. Here is how this file might look like for the apache webserver we had before.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;httpd:latest&lt;/span&gt;
   &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;80:80&lt;/span&gt;
   &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mywebsite/:/usr/local/apache2/htdocs/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Linking containers&lt;/h2&gt;
&lt;p&gt;Now imagine you are running a web application in a container, and you need access to various services such as a relational database and a cache server. These three services can be run in different containers talking to each others via links. You might notice the &lt;em&gt;expose&lt;/em&gt; keyword. Containers by default have all their ports closed. We previously seen that we could map a container's port to the host by using &lt;em&gt;ports&lt;/em&gt;. Thanks to &lt;em&gt;expose&lt;/em&gt;, we tell a container to open its port to other containers. Exposing a container's port does not make it accessible from the host.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;httpd:latest&lt;/span&gt;
   &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;80:80&lt;/span&gt;
   &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mywebsite/:/usr/local/apache2/htdocs/&lt;/span&gt;
   &lt;span class="nt"&gt;links&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;redis&lt;/span&gt;
  &lt;span class="nt"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;redis:latest&lt;/span&gt;
   &lt;span class="nt"&gt;expose&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;6379&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This post is certainly not exhaustive. It is just a quick introduction to Docker, and I emphasized on commands and practices I am using most of the time. Of course Docker has a very large number of additional functionnalities, and you should explore them while you work with containers. I hope this post was useful to get you started.&lt;/p&gt;</content><category term="docker"></category><category term="code"></category><category term="devops"></category></entry><entry><title>Deploying a Python Flask application to production</title><link href="https://ericdaat.github.io/deploy-python-flask-api.html" rel="alternate"></link><published>2017-05-28T10:20:00+02:00</published><updated>2017-05-28T10:20:00+02:00</updated><author><name>Eric Daoud</name></author><id>tag:ericdaat.github.io,2017-05-28:/deploy-python-flask-api.html</id><summary type="html">&lt;p&gt;In this post we are going to see how we can efficiently deploy a web application powered by Flask (a Python framework) to production. We won't code a complex application, actually we will just stick to the Flask Hello World example.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post we are going to see how we can efficiently deploy a web application powered by Flask (a Python framework) to production. We won't code a complex application, actually we will just stick to the Flask Hello World example.&lt;/p&gt;
&lt;h2&gt;Basic Flask application&lt;/h2&gt;
&lt;p&gt;If you've never heard of Flask before, I recommend you to visit its &lt;a href="http://flask.pocoo.org/"&gt;website&lt;/a&gt; and read about it.&lt;/p&gt;
&lt;p&gt;To create a Hello World application in Flask, just write the following code in a file called &lt;code&gt;application.py&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;index&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello, World!&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And then run the application with this code in a &lt;code&gt;main.py&lt;/code&gt; file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;application&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now run &lt;code&gt;python main.py&lt;/code&gt; and your app should be visible in your browser at &lt;code&gt;localhost:5000&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;WSGI server&lt;/h2&gt;
&lt;p&gt;So far we have a working application, but it won't be enough to serve a production environment. Python applications can't be directly deployed in a webserver, because python is not a web compatible language like Javascript or PHP for instance. Hence, we need an additional layer: a WSGI server.&lt;/p&gt;
&lt;p&gt;There are various WSGI servers on the market, &lt;a href="http://gunicorn.org/"&gt;Gunicorn&lt;/a&gt; is a popular choice but my favorite is &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/"&gt;uWSGI&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Getting started&lt;/h3&gt;
&lt;p&gt;You can install uWSGI with pip: &lt;code&gt;pip install uwsgi&lt;/code&gt;. Once you have it installed, you can run our previous python application within a WSGI webserver by simply doing &lt;code&gt;uwsgi main.py&lt;/code&gt;. You can pass many arguments to the &lt;code&gt;uwsgi&lt;/code&gt; command, but it is often prefered to have them all in a single configuration file. uWSGI can just do that, let's create a &lt;code&gt;uwsgi.ini&lt;/code&gt; configuration file that looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[uwsgi]
wsgi-file = main.py
master = true
processes = 2
http = 0.0.0.0:9000
vacuum = true
die-on-term = true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we can run the app with &lt;code&gt;uwsgi wsgi.ini&lt;/code&gt;. With such configuration, our Flask application will be hosted on 2 processes. This is an arbiratry number we set, but you can increase it either manually or automatically if you need to handle more trafic. The server will respond on &lt;code&gt;0.0.0.0:9000&lt;/code&gt;, which means that every client on the local network will be able to access the app on port 9000 using the HTTP protocol. Check that you can still see your app at &lt;code&gt;localhost:9000&lt;/code&gt;. You should also be able to see it from another device connected to the same network at &lt;code&gt;&amp;lt;your-ip&amp;gt;:9000&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Putting uWSGI behing NGINX reverse proxy&lt;/h2&gt;
&lt;p&gt;I like to run uWSGI behind a reverse proxy such as NGINX. This is fairly easy with this configuration file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;upstream backend {
    least_conn;
    server localhost:9000;
}

server {
    listen 80;
    location {
        uwsgi_pass backend;
        include uwsgi_params;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With such a configuration, NGINX listens on port 80 and redirects the requests to &lt;code&gt;localhost:9000&lt;/code&gt; which is our uwsgi server. Be careful though, since we use &lt;code&gt;uwsgi_pass&lt;/code&gt; command, the uwsgi application must run in a socket and not on http. Just change your &lt;code&gt;uwsgi.ini&lt;/code&gt; configuration file accordingly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[uwsgi]
wsgi-file = main.py
master = true
processes = 2
socket = 0.0.0.0:9000
vacuum = true
die-on-term = true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, just run the application with &lt;code&gt;uwsgi wsgi.ini&lt;/code&gt; and it will launch the
application with the configuration you just wrote. You can then write a startup
script with &lt;em&gt;upstart&lt;/em&gt; or &lt;em&gt;systemd&lt;/em&gt; to make your application run in the
background and easily start/stop it.&lt;/p&gt;
&lt;p&gt;In another post, I'll cover how to run all this with &lt;a href="https://www.docker.com/"&gt;Docker&lt;/a&gt;, as it is what I tend to use now to deploy apps in production.&lt;/p&gt;</content><category term="python"></category><category term="code"></category></entry></feed>